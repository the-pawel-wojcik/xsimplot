#!/usr/bin/env python

import argparse
import csv
import os
import sys
import math as m
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from matplotlib.ticker import MultipleLocator
import matplotlib.ticker as ticker
import numpy as np
import tomllib


DISREGARD_INTENSITY = 1e-20

COLORS = [color for color in mcolors.TABLEAU_COLORS.keys()]
FONTSIZE = 12
CM2INCH = 1/2.54

ZEKE_LINES_CM = [0.0, 616.8, 1219.9, 1815.3, 2465.5]
ZEKE_ADIABATIC_IE_CM = 101020.5
ZEKE_2ND_ADIABATIC_IE_CM = 102110.1
ZEKE_DISSOCIATION_THRESHOLD = ZEKE_ADIABATIC_IE_CM + 4898  # (3)
CM2eV = 1./8065.543937
eV2CM = 8065.543937

PYRAZINE_ABSORPTION_ORIGIN_CM = 30876

supported_units = {
    "eV": lambda x: x,
    "cm-1": lambda x: x * CM2eV,
    "nm": lambda x: 1239.84198 / x,
}


def ezFCF_label_helper(state):
    """
    turn st_number(n1vm1,n2vm2,...) into {m1: n1, m2: n2, ...}
    """
    vibrational_state = state.split('(')[1][:-1]  # omg )
    if vibrational_state == "0":
        return {}
    excitations = vibrational_state.split(',')
    out = {}
    for excitation in excitations:
        n_quanta, n_mode = excitation.split('v')
        out[int(n_mode)] = int(n_quanta)
    return out


def ezFCF_label_to_spectroscopic_label(assignment: str,
                                       first_is_the_lowest: bool = True):
    initial, final = assignment.split('->')
    initial = ezFCF_label_helper(initial)
    final = ezFCF_label_helper(final)
    active_modes = set(initial.keys()).union(set(final.keys()))
    active_modes = list(active_modes)
    active_modes.sort()
    if len(active_modes) == 0:
        return "0"

    out_str = ""
    for mode in active_modes:
        quanta_initial = 0
        if mode in initial:
            quanta_initial = initial[mode]
        quanta_final = 0
        if mode in final:
            quanta_final = final[mode]

        if first_is_the_lowest is True:
            up = quanta_final
            down = quanta_initial
        else:
            up = quanta_initial
            down = quanta_final
        out_str += f"{mode}$^{up}_{down}$"
    return out_str


def parse_command_line():
    # Parse the command line arguments.

    parser = argparse.ArgumentParser(description="Plot vibronic spectrum.")

    parser.add_argument("output_files",
                        help="List of files with the spectrum."
                        "The -n (--spectrum_format) flag controls the "
                        "spectrum format.",
                        nargs="+")

    parser.add_argument("-a", "--annotate",
                        help="Place string with the annotation on the figure."
                        "Use 'a' as the first letter of the string to append"
                        " the annotation generated by other flags; use 'o' to"
                        " overwrite.",
                        default="",
                        type=str)

    parser.add_argument("-p", "--position_annotation",
                        help="Place the annotation at",
                        choices=[
                            "top left", "top center", "top right",
                            "bottom left", "bottom center", "bottom right"
                        ],
                        default=None,
                        type=str
                        )

    parser.add_argument("-c", "--config",
                        help="Pick config file. "
                        "If not specified, look for xsimplot.toml.",
                        default="xsimplot.toml")

    parser.add_argument("-e", "--envelope",
                        help="Add a Lorenzian envelope to every peak.",
                        type=str,
                        default=None,
                        choices=['stack', 'overlay', 'sum only'])

    parser.add_argument("-g", "--gamma",
                        help="Gamma in the Lorenzian:\n" +
                        "(0.5 * gamma)**2 / ((x - x0)**2 + (0.5 * gamma) **2)",
                        type=float,
                        default=None)

    parser.add_argument("-i", "--all_intensities_even",
                        help="Use this switch to set all intenties to the"
                        " same value.",
                        type=float,
                        default=None)

    parser.add_argument("-I", "--rescale_intensities",
                        help="Multiply all intensiteis by the value.",
                        type=float,
                        default=None)

    parser.add_argument("-k", "--horizontal_minor_ticks_2nd_axis",
                        help="Specify the interval at which the minor ticks"
                        " should appear.",
                        type=float,
                        default=None)

    parser.add_argument("-K", "--horizontal_minor_ticks",
                        help="Specify the interval at which the minor ticks"
                        " should appear.",
                        type=float,
                        default=None)

    help = "Match some of the plot properties (like xlims or output location)"
    help += " to the selected molecule."
    parser.add_argument("-m", "--molecule",
                        help=help,
                        type=str,
                        choices=["ozone", "ozone_zeke", "ozone_dyke",
                                 "ozone_no_cpl", "pyrazine", "caoph"])

    parser.add_argument("-n", "--spectrum_format",
                        help="Chose the format of the spectrum file. 'xsim'"
                        "requires additional parser.",
                        default=None,  # defaults to fort.20 see code
                        type=str,
                        choices=["xsim", "fort.20", "ezFCF"])

    parser.add_argument("-r", "--scale_factor",
                        help="Scale the figure size with the factor.",
                        default=None,
                        type=float)

    parser.add_argument("-t", "--sticks_off",
                        help="Do NOT show stick spectrum.",
                        default=False,
                        action="store_true")

    parser.add_argument("-v", "--verbose",
                        help="Annotate with # of Lanczos it and basis size.",
                        default=False,
                        action="store_true")

    save = parser.add_mutually_exclusive_group()

    save.add_argument("-d", "--dont_save",
                      help="Just show the figure. Don't save it yet.",
                      default=False,
                      action="store_true")

    save.add_argument("-f", "--filename",
                      help="Save figure as filename.",
                      default=None)

    shift = parser.add_mutually_exclusive_group()

    help = "Shift simulated spectrum to align the first peak at <match_origin> eV."
    shift.add_argument("-o", "--match_origin",
                       default=None,
                       help=help)

    shift.add_argument("-s", "--shift_eV",
                       help="Positive shift moves peak towards lower energy.",
                       type=float)

    parser.add_argument("-x", "--second_axis",
                        help="Add a second energy axis; pick units. If you"
                        " want to see the offset from the first peak add"
                        " 'offset'.",
                        type=str,
                        choices=["cm", "cm offset", "nm"],
                        default=None)

    parser.add_argument("-y", "--show_yaxis_ticks",
                        help="Show ticks on the yaxis.",
                        default=None,
                        type=bool)

    args = parser.parse_args()
    return args


def height_one_lorenzian(x, x0, gamma):
    return lorenzian(x, x0, gamma) * m.pi * 0.5 * gamma


def lorenzian(x, x0, gamma):
    '''
    This definition of a Lorenzian comes from Eq. 2.40

    Köppel, H., W. Domcke, and L. S. Cederbaum. “Multimode Molecular Dynamics
    Beyond the Born-Oppenheimer Approximation.” In Advances in Chemical Physics
    edited by I. Prigogine and Stuart A. Rice, LVII:59–246, 1984.
    https://doi.org/10.1002/9780470142813.ch2.

    gamma corresponds to full width at half max (FWHM)
    '''
    return 1.0 / m.pi * (0.5 * gamma / ((x - x0)**2 + (0.5 * gamma) ** 2))


def turn_spectrum_to_xs_and_ys(spectrum):
    xs = []
    ys = []
    for spectral_point in spectrum:
        xs += [spectral_point['Energy (eV)']]
        ys += [spectral_point['Relative intensity']]

    return xs, ys


def lorenz_intensity(x, gamma, xsim_output):
    out = 0.0
    for spectral_point in xsim_output:
        energy_eV = spectral_point['Energy (eV)']
        intensity = spectral_point['Relative intensity']
        out += intensity * height_one_lorenzian(x, energy_eV, gamma)
    return out


def stem_xsim_output(xsim_output, ax, color: str = 'k'):
    for spectral_point in xsim_output:
        energy_eV = spectral_point['Energy (eV)']
        intensity = spectral_point['Relative intensity']
        ax.vlines(x=energy_eV, ymin=0.0, ymax=intensity, colors=color)


def stem_ozone_zeke(xsim_output, ax, color: str = 'k'):
    for spectral_point in xsim_output:
        energy_eV = spectral_point['Energy (eV)']
        intensity = 1.0
        ax.vlines(x=energy_eV, ymin=0.0, ymax=intensity, colors=color)


def get_xsim_outputs_from_fort20(args):
    xsim_outputs = []
    lanczos = None
    for file_idx, fort20_file in enumerate(args.output_files):

        with open(fort20_file, 'r') as f:
            fort20 = f.readlines()

        loc_lanczos = int(fort20[0].split()[0])
        if lanczos is None:
            lanczos = loc_lanczos
        elif loc_lanczos != lanczos:
            print("Warning: the number of Lanczos iterations in the input"
                  f" file #{file_idx} differs from the previous files.",
                  file=sys.stderr)

        xsim_output = []
        first_peak_cm = float(fort20[1].split()[0]) * eV2CM
        for peak in fort20[1:]:
            peak = peak.split()
            try:
                intensity = float(peak[1])
            except ValueError:
                # for tiny tiny intensities xsim produces garbage, i.e.:
                # 6.86644579832093   0.159775868164848-105  39294.6062024455
                exponent = int(peak[1][-4:])
                if exponent < -99:
                    continue
                print("Error: cannot process the line:" + peak,
                      file=sys.stderr)
                sys.exit(1)
            if intensity < DISREGARD_INTENSITY:
                continue
            offset = float(peak[2])
            data = {
                'Energy (eV)': float(peak[0]),
                'Energy (cm-1)': first_peak_cm + offset,
                'Offset (cm-1)': offset,
                'Relative intensity': float(peak[1]),
            }
            xsim_output += [data]

        xsim_outputs += [xsim_output]

    return xsim_outputs, lanczos


def get_xsim_outputs(args):
    from parsers.xsim import parse_xsim_output
    xsim_outputs = []
    basis = None
    lanczos = None
    for file_idx, out_file in enumerate(args.output_files):
        with open(out_file) as f:
            xsim_data = parse_xsim_output(f)

        xsim_output = xsim_data['spectrum_data']
        xsim_outputs += [xsim_output]

        loc_basis = xsim_data['basis']
        if basis is None:
            basis = loc_basis
        elif basis != loc_basis:
            print("Warning: Outputs use different basis sets.",
                  file=sys.stderr)

        loc_lanczos = xsim_data['Lanczos']
        if lanczos is None:
            lanczos = loc_lanczos
        elif lanczos != loc_lanczos:
            print("Warning! Outputs use different # of Lanczos iterations.",
                  file=sys.stderr)

    return xsim_outputs, basis, lanczos


def get_ezFCF_spectrum(args):
    spectra = []
    for file_idx, out_file in enumerate(args.output_files):
        with open(out_file) as f:
            lines = f.readlines()

        ezFCF_spectrum = []
        for line in lines:
            splitline = line.split()
            data = {
                'Energy (eV)': float(splitline[0]),
                'Relative intensity': float(splitline[1]),
                'FCF': float(splitline[2]),
                'ezFCF assignment': splitline[4],
            }
            ezFCF_spectrum += [data]

        # Add other data that xsim offers
        origin_eV = ezFCF_spectrum[0]['Energy (eV)']
        for peak in ezFCF_spectrum:
            energy_eV = peak['Energy (eV)']
            peak['Energy (cm-1'] = energy_eV * eV2CM
            peak['Offset (cm-1'] = (energy_eV - origin_eV) * eV2CM

        spectra += [ezFCF_spectrum]

    return spectra


def find_shift(xsim_outputs, args, config):
    """
    Find shift (in eV) which will be applied to the spectrum.
    The shift is
    """

    # Command line args are the most important
    if args.shift_eV is not None:
        return args.shift_eV

    first_peak_position = None

    if 'match_origin' in config:
        first_peak_position = config['match_origin']

    if args.match_origin is not None:
        first_peak_position = args.match_origin

    # if args.molecule is not None:
    #     if args.molecule == "ozone":
    #         # Position of the first ionization energy of ozone
    #         first_peak_position = ZEKE_ADIABATIC_IE_CM * CM2eV
    #     elif args.molecule == "ozone_zeke":
    #         # Position of the first ionization energy of ozone
    #         first_peak_position = ZEKE_ADIABATIC_IE_CM * CM2eV
    #     elif args.molecule == "ozone_dyke":
    #         # Position of the first ionization energy of ozone
    #         first_peak_position = ZEKE_ADIABATIC_IE_CM * CM2eV
    #     # elif args.molecule == "ozone_no_cpl":
    #     #     # Position of the first ionization energy of ozone
    #     #     first_peak_position = ZEKE_ADIABATIC_IE_CM * CM2eV
    #     elif args.molecule == "pyrazine":
    #         first_peak_position = PYRAZINE_ABSORPTION_ORIGIN_CM * CM2eV

    if first_peak_position is not None:
        origins = []
        for xsim_output in xsim_outputs:
            min_element = min(xsim_output, key=lambda x: x['Energy (eV)'])
            origins.append(min_element['Energy (eV)'])
        origin_eV = min(origins)
        shift_eV = origin_eV - first_peak_position
        return shift_eV

    return None


def find_left_right_gamma(xsim_outputs, args, config, how_far: int = 4):
    """
    Find the positions of the lowest energy and highest energy peaks and return
    values how_far*gamma away from them as the plot limits.
    """

    gamma_eV = find_gamma(args, config)

    # Commnad line is the most important
    if args.molecule is not None and args.molecule not in [
            "ozone_dyke", "ozone", "ozone_zeke", "ozone_no_cpl"
    ]:
        # if args.molecule == "ozone" or args.molecule == "ozone_zeke":
        #     # First photoelectron band of ozone
        #     left = 12.225
        #     right = 13.375

        # if args.molecule == "ozone_no_cpl":
        #     # First photoelectron band of ozone
        #     left = 12.225
        #     right = 13.375

        if args.molecule == "pyrazine":
            # First absorption band of pyrazine
            # left = 3.75
            # right = 4.25
            left = 3.8
            right = 4.0
            # # For 1st band absorption
            # left = 3.5
            # right = 4.5

        elif args.molecule == "caoph":
            left = 1.95
            right = 2.35

        return (left, right, gamma_eV)

    # Config file is the second most important resource
    if 'xlims' in config:
        left = config['xlims']['left']
        right = config['xlims']['right']
        return (left, right, gamma_eV)

    # Finally find some default values
    mins = list()
    maxes = list()

    for xsim_output in xsim_outputs:
        min_element = min(xsim_output, key=lambda x: x['Energy (eV)'])
        max_element = max(xsim_output, key=lambda x: x['Energy (eV)'])
        mins.append(min_element['Energy (eV)'])
        maxes.append(max_element['Energy (eV)'])

    minimum = min(mins)
    maximum = max(maxes)
    left = minimum - how_far * gamma_eV
    right = maximum + how_far * gamma_eV

    return (left, right, gamma_eV)


def apply_shift(xsim_outputs, shift_eV):
    if shift_eV is None:
        return xsim_outputs

    for output in xsim_outputs:
        for peak in output:
            peak['Energy (eV)'] -= shift_eV

    return xsim_outputs


def add_envelope(ax, args, config, xsim_outputs, xlims, gamma):

    envelope_type = None
    if 'envelope' in config:
        envelope_type = config['envelope']
    # Command line args override config options
    if args.envelope is not None:
        envelope_type = args.envelope

    if envelope_type is None:
        return 0.0

    npoints = 500
    xs = np.linspace(xlims[0], xlims[1], npoints)
    accumutated_ys = np.zeros_like(xs)

    for file_idx, xsim_output in enumerate(xsim_outputs):
        if file_idx == len(COLORS) or file_idx > len(COLORS):
            print("Too many colors already.", file=sys.stderr)
            sys.exit(1)

        state_spectrum = [lorenz_intensity(x, gamma, xsim_output) for x in xs]
        state_spectrum = np.array(state_spectrum)
        color = COLORS[file_idx]
        if envelope_type == "stack":
            ax.fill_between(xs, accumutated_ys + state_spectrum,
                            accumutated_ys, color=color, alpha=0.2)
        elif envelope_type == "overlay":
            ax.fill_between(xs, state_spectrum, np.zeros_like(xs), color=color,
                            alpha=0.2)
        accumutated_ys += state_spectrum

    dashed = (0, (5, 5))
    densly_dashdotted = (0, (3, 1, 1, 1))
    # Plot the total spectrum extra for overlay
    if envelope_type in ["overlay", "sum only"]:
        if args.molecule == "ozone_dyke":
            # Dyke-like
            # ax.fill_between(xs, accumutated_ys, np.zeros_like(xs),
            #                 color='tab:green', alpha=0.2, label='simulation')
            ax.plot(xs, accumutated_ys, color='tab:blue', lw=1.5,
                    ls=densly_dashdotted, label='simulation')
            ax.plot([], [], color='k', lw=1.5, label="experiment")
        else:
            ax.plot(xs, accumutated_ys, color='tab:gray', lw=1)

    fig_max_y = np.max(accumutated_ys)

    if args.molecule == "ozone_dyke":
        ax.legend()

    return fig_max_y


def add_peaks(ax, args, config, xsim_outputs, xlims):
    sticks_off = False
    if 'sticks_off' in config:
        sticks_off = config['sticks_off']
    if args.sticks_off is True:
        sticks_off = True

    if sticks_off is True:
        return 0.0

    peaks_maxima = []
    for file_idx, xsim_output in enumerate(xsim_outputs):
        if file_idx == len(COLORS) or file_idx > len(COLORS):
            print("Too many colors already.", file=sys.stder)
            sys.exit(1)

        my_peaks = [
            peak for peak in xsim_output if
            peak['Energy (eV)'] >= xlims[0] and peak['Energy (eV)'] <= xlims[1]
        ]
        if args.molecule == "ozone_zeke":
            stem_ozone_zeke(my_peaks, ax, COLORS[file_idx])
        else:
            stem_xsim_output(my_peaks, ax, COLORS[file_idx])

        max_peak = max(my_peaks, key=lambda x: x['Relative intensity'])
        peaks_maxima.append(max_peak['Relative intensity'])

    return max(peaks_maxima)


def add_info_text(ax, args, config, shift_eV, basis, lanczos, gamma):

    info_kwargs = {
        'fontsize': FONTSIZE,
        'color': 'k',
        'transform': ax.transAxes,
    }

    # the options translated to settings
    horizontalalignment = {
        "top left": "left",
        "top center": "center",
        "top right": "right",
        "bottom left": "left",
        "bottom center": "center",
        "bottom right": "right",
    }

    verticalalignment = {
        "top left": "top",
        "top center": "top",
        "top right": "top",
        "bottom left": "bottom",
        "bottom center": "center",
        "bottom right": "bottom",
    }

    x_position = {
        "top left": 0.01,
        "top center": 0.5,
        "top right": 0.99,
        "bottom left": 0.01,
        "bottom center": 0.5,
        "bottom right": 0.99,
    }

    y_position = {
        "top left": 0.99,
        "top center": 0.99,
        "top right": 0.99,
        "bottom left": 0.01,
        "bottom center": 0.01,
        "bottom right": 0.01,
    }

    position = "top left"  # default
    if 'position_annotation' in config:  # allow to set it from the config
        position = config['position_annotation']
        if position not in x_position:
            print("Error: Invalid option present in the config file:\n\t"
                  f"position_annotation = '{position}'\n\t"
                  f"Allowed values: {", ".join(x_position.keys())}",
                  file=sys.stderr)
            sys.exit(1)
    if args.position_annotation is not None:  # command line can overwrite
        position = args.position_annotation

    info_kwargs['horizontalalignment'] = horizontalalignment[position]
    info_kwargs['verticalalignment'] = verticalalignment[position]

    text = ""

    envelope_type = None
    if 'envelope' in config:
        envelope_type = config['envelope']
    if args.envelope is not None:
        envelope_type = args.envelope

    if envelope_type is not None:
        text = r'$\gamma = ' + f'{gamma:.3f}$\n'

    if shift_eV is not None:
        text += f'$s = {shift_eV:.2f}$ eV'

    verbose = False
    if 'verbose' in config:
        verbose = config['verbose']
    if args.verbose is True:
        verbose = True

    if verbose is True:
        if basis is not None:
            text += f'\nBasis: {basis.split()[0]}'
        text += f'\nLanczos: {lanczos}'

    annotation = ""
    if 'annotate' in config:
        annotation = config['annotate']
    if args.annotate != "":
        annotation = args.annotate

    if annotation != "":
        text_with_newline = "\n".join(annotation[1:].split(r'\n'))
        # append
        if annotation[0] == "a":
            text += "\n" + text_with_newline
        # overwrite
        elif annotation[0] == "o":
            text = text_with_newline
        else:
            print("Warning: The annotation texts needs to start with either"
                  " 'a' or 'o', see help for details.", file=sys.stderr)

    ax.text(x_position[position], y_position[position], text, **info_kwargs)


def add_caoph_lines(ax, top_feature):
    CAOPH_LINES = [
        {'pos_cm': 0.0, 'height': 660, 'lbl': 'A'},
        {'pos_cm': 0.0, 'height': 660, 'lbl': 'A'},
    ]

    max_height = max([x['height'] for x in CAOPH_LINES])

    # top_feature = 0.038
    # For now I print only the first band
    top_feature = 0.004
    # For the 2200 cm offset
    # top_feature = 0.022

    step = 0.075 * top_feature
    y_top = 0.85 * top_feature
    y_bottom = 0.825 * top_feature

    line_kwargs = {'color': 'gray',
                   'linestyles': 'solid',
                   'linewidths': 1,
                   'alpha': 0.2}
    text_kwargs = {'va': 'center',
                   'ha': 'center'}

    for line in CAOPH_LINES:
        pos_cm = line['pos_cm']
        lttr = line['lbl']
        if 'height' in line:
            height = line['height'] / max_height * top_feature
            y_text = height
            y_peak = height
        else:
            series = line['series']
            y_text = y_top - series * step
            y_peak = y_bottom - series * step
        x_cm = pos_cm + PYRAZINE_ABSORPTION_ORIGIN_CM
        x_eV = x_cm * CM2eV
        ax.text(x_eV, y_text, lttr, **text_kwargs)
        ax.vlines([x_eV], 0.0, [y_peak], **line_kwargs)


def add_pyrazine_lines(ax, top_feature):
    PYRAZINE_LINES = [
        {'pos_cm': 0.0, 'height': 660, 'lbl': '0', 'series': 0},
        {'pos_cm': 383, 'height': 487, 'lbl': r'$10a ^1$', 'series': 1},
        # {'pos_cm': 467, 'lbl': r'$16 b^2$', 'series': 3},
        {'pos_cm': 517, 'height': 122, 'lbl': r'$5 ^1$', 'series': 4},
        {'pos_cm': 583, 'height': 350, 'lbl': r'$6a ^1$', 'series': 2},
        {'pos_cm': 823, 'height': 273, 'lbl': r'$10 a^2$', 'series': 1},
        {'pos_cm': 945, 'height': 231, 'lbl': r'$10 a^1 6 a^1$', 'series': 3},
        # {'pos_cm': 1167, 'lbl': r'$6a ^2$', 'series': 2},
    ]

    max_height = max([x['height'] for x in PYRAZINE_LINES if 'height' in x])

    # top_feature = 0.038
    # For now I print only the first band
    top_feature = 0.004
    # For the 2200 cm offset
    # top_feature = 0.022

    step = 0.075 * top_feature
    y_top = 0.85 * top_feature
    y_bottom = 0.825 * top_feature

    line_kwargs = {'color': 'gray',
                   'linestyles': 'solid',
                   'linewidths': 1,
                   'alpha': 0.2}
    text_kwargs = {'va': 'center',
                   'ha': 'center'}

    for line in PYRAZINE_LINES:
        pos_cm = line['pos_cm']
        lttr = line['lbl']
        if 'height' in line:
            height = line['height'] / max_height * top_feature
            y_text = height
            y_peak = height
        else:
            series = line['series']
            y_text = y_top - series * step
            y_peak = y_bottom - series * step
        x_cm = pos_cm + PYRAZINE_ABSORPTION_ORIGIN_CM
        x_eV = x_cm * CM2eV
        ax.text(x_eV, y_text, lttr, **text_kwargs)
        ax.vlines([x_eV], 0.0, [y_peak], **line_kwargs)


def add_ZEKE_lines(ax, top_feature):
    y_top = 1.1 * top_feature
    y_bottom = 1.075 * top_feature
    xs = []
    for lttr, pos in zip(['B', 'C', 'D', 'E', 'F'], ZEKE_LINES_CM):
        x = pos + ZEKE_ADIABATIC_IE_CM
        x_ev = x * CM2eV
        xs.append(x_ev)
        ax.text(x_ev, y_top, lttr, va='center', ha='center')

    ax.vlines(xs, 0.0, y_bottom, color='gray', linestyles='solid',
              linewidths=1, alpha=0.2)

    # ax.vlines(xs, y_bottom, y_top, color = 'k')
    # ax.hlines(y_top, xs[0], xs[-1], color = 'k')
    # add the 2nd IE line

    # x = ZEKE_2ND_ADIABATIC_IE_CM
    # x_ev = x * CM2eV
    # lttr = r'$\tilde{A} ^+ (0,0,0)$'
    # lttr = r'$\tilde{A} ^+$'
    # # lttr = r'$IE _2$'
    # # y_bottom *= 0.9
    # # y_top *= 0.9
    # ax.text(x_ev, y_top, lttr, va='center', ha='center')
    # ax.vlines(x_ev, 0.0, y_bottom, color='gray', linestyles='solid',
    #           linewidths=1, alpha=0.2)

    x = ZEKE_DISSOCIATION_THRESHOLD
    x_ev = x * CM2eV
    lttr = r'$D _0$'
    ax.text(x_ev, y_top, lttr, va='center', ha='center')
    ax.vlines(x_ev, 0.0, y_bottom, color='gray', linestyles='solid',
              linewidths=1, alpha=0.2)

    CONICAL_INTERSECTION = 104194.3
    x = CONICAL_INTERSECTION
    x_ev = x * CM2eV
    lttr = 'CI'
    ax.text(x_ev, y_top, lttr, va='center', ha='center')
    ax.vlines(x_ev, 0.0, y_bottom, color='gray', linestyles=':',
              linewidths=1, alpha=0.2)


def add_assignmnet_to_ZEKE_lines(ax, top_feature):

    uncoupled_like = [
        [0, "A000"],
        [618, "A010"],
        # [915, r"A001$^*$"],
        [915, r"A001"],
        [1076, "A100"],
        [1222, "A020"],
        [1368, "B000"],
        [1684, "A110"],
    ]

    leading_order = [
        [1796, "A030", 0.87],
        [1921, "B010", 0.74],
        [2275, "A120", 0.74],
        [2362, "A040", 0.38],
        [2886, "A130", 0.66],
        [3045, "A050", 0.58],
    ]

    text_kw = dict(va='bottom', ha='left', rotation=35,
                   rotation_mode='anchor')

    y_top = top_feature
    y_top = 1.1 * top_feature
    y_bottom = 1.075 * top_feature
    xs = []
    for peak in uncoupled_like:
        pos = peak[0]
        name = peak[1]
        assignmnet = ""
        if name[0] == "A":
            assignmnet += r"A$_1("
        elif name[0] == "B":
            assignmnet += r"B$_2("
        assignmnet += name[1:4]
        assignmnet += ")$"
        if len(name) > 4:
            assignmnet += name[4:]

        x = pos + ZEKE_ADIABATIC_IE_CM
        x_ev = x * CM2eV
        xs.append(x_ev)
        ax.text(x_ev, y_top, assignmnet, **text_kw)

    # ax.vlines(xs, 0.0, y_bottom, color='gray', linestyles='solid',
    #           linewidths=1, alpha=0.2)

    for peak in leading_order[:-2]:
        pos = peak[0]
        name = peak[1]
        percentage = peak[2]
        assignmnet = f"{100*percentage**2:.0f}%"
        if name[0] == "A":
            assignmnet += r"A$_1$("
        elif name[0] == "B":
            assignmnet += r"B$_2$("
        assignmnet += name[1:5]
        assignmnet += ")"

        x = pos + ZEKE_ADIABATIC_IE_CM
        x_ev = x * CM2eV
        xs.append(x_ev)
        ax.text(x_ev, y_top, assignmnet, **text_kw)

    text_kw = dict(va='bottom', ha='right', rotation=-20,
                   rotation_mode='anchor')

    for peak in leading_order[-2:]:
        pos = peak[0]
        name = peak[1]
        percentage = peak[2]
        assignmnet = f"{100*percentage**2:.0f}%"
        if name[0] == "A":
            assignmnet += r"A$_1$("
        elif name[0] == "B":
            assignmnet += r"B$_2$("
        assignmnet += name[1:5]
        assignmnet += ")"

        x = pos + ZEKE_ADIABATIC_IE_CM
        x_ev = x * CM2eV
        xs.append(x_ev)
        ax.text(x_ev, y_top, assignmnet, **text_kw)


def add_no_cpl_lines(ax):

    lines = {
        "A000": 0, "A010": 628, "A100": 1083, "A020": 1249, "B000": 1412,
        "A110": 1708, "A030": 1863, "B010": 2061, "A120": 2325,
        "A040": 2470, "B020": 2708, "A130": 2936, "A050": 3068,
        "B110": 3247, "B030": 3353, "A140": 3539, "A060": 3656,
        "B120": 3888, "B040": 3996, "A150": 4134, "A070": 4234,
        "B130": 4527, "B050": 4636, "A080": 4801, "B140": 5163,
        "B060": 5275, "A090": 5353, "B150": 5802, "B070": 5909,
    }

    xs = {
        "A0": [],
        "A1": [],
        "B0": [],
        "B1": [],
    }
    y_tops = {
        "A0": 0.5,
        "A1": 0.6,
        "B0": 0.7,
        "B1": 0.8,
    }
    y_bottoms = {
        "A0": 0.5,
        "A1": 0.6,
        "B0": 0.7,
        "B1": 0.8,
    }

    for name, pos in lines.items():
        series = name[0:2]
        y_top = y_tops[series]
        x_ev = (ZEKE_ADIABATIC_IE_CM + pos) * CM2eV
        xs[series].append(x_ev)
        lttr = name[2]
        ax.text(x_ev, y_top, lttr, va='bottom', ha='center')

    tick_height = 0.015
    for series in ["A0", "A1", "B0", "B1"]:
        if series[0] == "A":
            color = 'tab:blue'
        elif series[0] == "B":
            color = 'tab:orange'

        y_bottom = y_bottoms[series]
        ax.vlines(xs[series], y_bottom-tick_height, y_bottom, color=color,
                  linestyles='solid', linewidths=1)

        x_min = xs[series][0]
        x_max = xs[series][-1]
        ax.hlines(y_bottom, x_min, x_max, color=color,
                  linestyles='solid', linewidths=1)

        # Add the series header
        name = series[0]
        if series[0] == "A":
            name += r"$_1$("
        else:
            name += r"$_2$("
        name += series[1] + "n0)"
        header_x_offset = -0.01
        ax.text(x_min + header_x_offset, y_bottom, name,
                va='center', ha='right')


def prepare_filename(args, config):

    # User can say the name
    user_filename = None
    if 'filename' in config:
        user_filename = config['filename']
    if args.filename is not None:
        user_filename = args.filename

    if user_filename is not None:
        return user_filename

    # If the user does not say the name create one yourself
    path = os.path.expanduser('~')
    if args.molecule is not None:
        if args.molecule == "ozone":
            path += '/ozone/plotter/pics'
        elif args.molecule == "pyrazine":
            path += '/pyrazine/calculations/absorption-spectra/xsim/pics'

    filename = path + "/"
    for idx, outname in enumerate(args.output_files):
        if idx > 0:
            filename += "+"
        filename += os.path.basename(outname)
    filename += '_spectrum.pdf'

    return filename


def find_gamma(args, config):
    gamma = None
    if 'gamma' in config:
        gamma = config['gamma']

    if args.molecule is not None and args.molecule == "pyrazine":
        gamma = 0.001

    # Command line argument takes precedence
    if args.gamma is not None:
        gamma = args.gamma

    # default value
    if gamma is None:
        gamma = 0.03

    return gamma


def get_origin(xsim_outputs):
    origin = None
    for xsim_output in xsim_outputs:
        min_element = min(xsim_output, key=lambda x: x['Energy (eV)'])
        loc_origin = min_element['Energy (eV)']
        if origin is None:
            origin = loc_origin
        elif origin > loc_origin:
            origin = loc_origin

    return origin


def add_minor_ticks(args, config, ax):
    interval = None
    if 'horizontal_minor_ticks' in config:
        interval = config['horizontal_minor_ticks']
    if args.horizontal_minor_ticks is not None:
        interval = args.horizontal_minor_ticks

    if interval is None:
        return

    ax.xaxis.set_minor_locator(MultipleLocator(interval))


def add_second_axis(args, config, ax, origin_eV):

    second_axis = None

    if 'second_axis' in config:
        second_axis = config['second_axis']
    if args.second_axis is not None:
        second_axis = args.second_axis

    if second_axis is None:
        return

    if second_axis == "cm offset":
        add_cm_scale(ax, args, config, origin_eV)

    elif second_axis == "cm":
        add_cm_scale(ax, args, config)

    elif second_axis == "nm":
        add_nm_scale(args, ax)


def add_cm_scale(ax, args, config, origin_eV: float = None):
    ax_cm = ax.twiny()

    if origin_eV is None:
        origin_cm = 0
    else:
        origin_cm = origin_eV * eV2CM

    x1, x2 = ax.get_xlim()
    x1 = x1 * eV2CM - origin_cm
    x2 = x2 * eV2CM - origin_cm

    ax_cm.set_xlim(x1, x2)

    interval = None
    if 'horizontal_minor_ticks_2nd_axis' in config:
        interval = config['horizontal_minor_ticks_2nd_axis']
    if args.horizontal_minor_ticks_2nd_axis is not None:
        interval = args.horizontal_minor_ticks_2nd_axis

    if interval is not None:
        ax_cm.xaxis.set_minor_locator(MultipleLocator(interval))

    if args.molecule == "ozone":
        ax_cm.xaxis.set_minor_locator(MultipleLocator(200))
        # ax.xaxis.set_minor_locator(MultipleLocator(0.05))

    elif args.molecule == "ozone_zeke":
        ax_cm.xaxis.set_ticks([101100 + 300 * i for i in range(11)])
        ax_cm.xaxis.set_minor_locator(MultipleLocator(150))
        ax.xaxis.set_minor_locator(MultipleLocator(0.01))

    elif args.molecule == "ozone_dyke":
        # ax_cm.xaxis.set_ticks([101100 + 300 * i for i in range(11)])
        ax_cm.xaxis.set_minor_locator(MultipleLocator(200))
        ax.xaxis.set_ticks(np.linspace(start=12.5, stop=13.25, num=4))

    elif args.molecule == "ozone_no_cpl":
        ax_cm.xaxis.set_minor_locator(MultipleLocator(200))
        ax.xaxis.set_ticks(np.linspace(start=12.5, stop=13.25, num=4))

    # elif args.molecule == "pyrazine":
    #     ax_cm.xaxis.set_minor_locator(MultipleLocator(100))
    #     ax.xaxis.set_minor_locator(MultipleLocator(0.01))


def add_nm_scale(args, ax):
    r"""
    Relation between photon's energy and wavelength:
        E = hc / \lambda
    """
    ToLambda = 1239.84198  # from eV to nm
    ax_nm = ax.twiny()

    x1, x2 = ax.get_xlim()
    x1 = ToLambda / x1
    x2 = ToLambda / x2

    ax_nm.set_xlim(x1, x2)
    if args.molecule == "caoph":
        ax_nm.xaxis.set_minor_locator(MultipleLocator(5))
        ax.xaxis.set_minor_locator(MultipleLocator(0.01))

    # if args.molecule == "ozone":
    #     ax.xaxis.set_minor_locator(MultipleLocator(0.05))


def get_fig_and_ax(args, config):

    # Scale factor is used to resize the figure in both direction
    # Making the figures smaller is the same as making the text larger
    scale_factor = 1.0
    if 'scale_factor' in config:
        scale_factor = config['scale_factor']
    if args.scale_factor is not None:
        scale_factor = args.scale_factor

    # Aspect ratio = width/height
    # width = height * ar
    aspect_ratio = 1.0
    if 'aspect_ratio' in config:
        aspect_ratio = config['aspect_ratio']

    # The default figure size is 12cm x 12 cm. Smaller should be better.
    FIGSIZE = 12 * CM2INCH * scale_factor
    fig, ax = plt.subplots(figsize=(FIGSIZE * aspect_ratio, FIGSIZE))
    return fig, ax


def add_assignments(ax, args, config, top_feature):
    if args.molecule is not None:
        if args.molecule == "ozone":
            add_ZEKE_lines(ax, top_feature)

        # elif args.molecule == "ozone_zeke":
        #     # add_ZEKE_lines(ax, 1.1)
        #     add_assignmnet_to_ZEKE_lines(ax, 1.0)
        elif args.molecule == "ozone_no_cpl":
            # add_ZEKE_lines(ax, top_feature)
            add_no_cpl_lines(ax)

#         elif args.molecule == "ozone_dyke":
#             add_ZEKE_lines(ax, 0.47)  # for the no couplings case

        elif args.molecule == "pyrazine":
            add_pyrazine_lines(ax, top_feature)

        elif args.molecule == "caoph":
            add_caoph_lines(ax, top_feature)

    if "reference_peaks" not in config:
        return

    print("Info: Adding reference peaks from the config file.",
          file=sys.stderr)

    # TODO: assure that reference_peaks are propertly formatted.
    scale_assignment_peaks = -2e-5
    peaks = config['reference_peaks']
    for peak in peaks:
        energy = peak['energy']
        energy_unit = peak['energy_unit']
        amplitude = peak['amplitude'] * scale_assignment_peaks
        assignment = peak['assignment']

        if energy_unit not in supported_units:
            print(f"Error: energy units other than {supported_units.keys()}"
                  " are not supported in 'reference_peaks' array.",
                  file=sys.stderr)
            sys.exit(1)
        x_eV = supported_units[energy_unit](energy)

        text_kwargs = {
            'ha': 'center',
        }
        if amplitude < 0.0:
            text_kwargs['va'] = 'top'
        else:
            text_kwargs['va'] = 'bottom'

        line_kwargs = {
            'color': 'k',
            'linestyles': 'solid',
            # 'linewidths': 1,
            # 'alpha': 0.8
        }
        ax.text(x_eV, amplitude, assignment, **text_kwargs)
        ax.vlines([x_eV], 0.0, [amplitude], **line_kwargs)


def collect_reference_spectra_config(spectrum):
    unit = 'eV'
    if 'energy_units' in spectrum:
        unit = spectrum['energy_units']
        if unit not in supported_units:
            print("Error: energy units other than "
                  f"{supported_units.keys()}"
                  " are not supported by 'reference_spectrum'.",
                  file=sys.stderr)
            sys.exit(1)
    else:
        print("Info: Energy unit in the reference_spectrum section of the"
              " config file is not specified. Using the default: 'eV'.",
              file=sys.stderr)

    rescale_factor = 1.0
    if 'rescale_intensities' in spectrum:
        rescale_factor = float(spectrum['rescale_intensities'])
    else:
        print("Info: rescale_intensities not specified in the "
              "reference_spectrum section of the config file."
              "Using intensities from the csv file.",
              file=sys.stderr)

    match_origin = None
    if 'match_origin' in spectrum:
        match_origin = float(spectrum['match_origin'])
        print("Info: Matching the reference spectrum against the origin at"
              f" {match_origin} {unit}.",
              file=sys.stderr)

    plot_type = 'stems'
    if 'plot_type' in spectrum:
        plot_type = spectrum['plot_type']
    else:
        print("Info: plot_type not specified in the "
              "reference_spectrum section of the config file."
              "Using the default.",
              file=sys.stderr)

    if plot_type not in ['scatter', 'stems', 'plot']:
        print("Error: The only supported values of 'plot_type' in the "
              "'reference_spectrum' part of the config file are 'scatter'"
              ", 'stems', and 'plot' ", file=sys.stderr)
        sys.exit(1)

    if 'file' not in spectrum:
        print("Error: 'reference_spectrum' is missing the 'file' line.",
              file=sys.stderr)
        sys.exit(1)

    y_offset = 0.0
    if 'y_offset' in spectrum:
        y_offset = spectrum['y_offset']

    file_name = spectrum['file']
    file_name = os.path.expanduser(file_name)

    return unit, rescale_factor, plot_type, y_offset, file_name, match_origin


def plot_reference_spectra_assignments(
        ax, spectrum_data, unit, rescale_factor, y_offset
):
    convert_to_eV = supported_units[unit]
    text_kwargs = {
        'ha': 'center',
    }
    for peak in spectrum_data:
        if peak['assignment'] is None:
            continue
        x_eV = convert_to_eV(float(peak['energy']))
        amplitude = float(peak['intensity']) * rescale_factor
        if amplitude < 0.0:
            text_kwargs['va'] = 'top'
        else:
            text_kwargs['va'] = 'bottom'

        text = peak['assignment']
        ax.text(x_eV, y_offset + amplitude, text, **text_kwargs)


def add_reference_spectra(ax, args, config):
    if "reference_spectrum" not in config:
        return

    for spectrum in config['reference_spectrum']:
        unit, rescale_factor, plot_type, y_offset, file_name, match_origin = \
            collect_reference_spectra_config(spectrum)

        spectrum_data = []
        assignments_are_available = False
        with open(file_name, 'r', newline='') as spectrum_file:
            reader = csv.DictReader(spectrum_file)
            assignments_are_available = 'assignment' in reader.fieldnames
            for row in reader:
                spectrum_data += [row]

        line_kwargs = {
            'color': 'k',
            'linestyles': 'solid',
            # 'linewidths': 1,
            # 'alpha': 0.8
        }

        if match_origin is not None:
            shift = float(spectrum_data[0]['energy']) - match_origin
            for peak in spectrum_data:
                peak['energy'] = float(peak['energy']) - shift

        if assignments_are_available is True:
            plot_reference_spectra_assignments(
                ax, spectrum_data, unit, rescale_factor, y_offset
            )

        spectrum_list = [
            [
                supported_units[unit](float(row['energy'])),
                float(row['intensity']) * rescale_factor,
            ] for row in spectrum_data
        ]
        # transpose
        xs, ys = [list(a) for a in zip(*spectrum_list)]
        if plot_type == 'stems':
            ax.vlines(
                xs,
                [y_offset for _ in ys],
                [y + y_offset for y in ys],
                label=None,
                **line_kwargs)

        elif plot_type == "scatter":
            ax.scatter(xs, [y_offset + y for y in ys])

        elif plot_type == "plot":
            ax.plot(xs, [y_offset + y for y in ys])


def add_ezFCF_assignments(ax, args, config, spectra, top_feature):
    for peaks in spectra:
        for peak in peaks:
            energy_eV = peak['Energy (eV)']
            amplitude = peak['Relative intensity']
            assignment = peak['ezFCF assignment']

            text_kwargs = {
                'ha': 'center',
                'va': 'bottom',
            }
            # Disregard small features
            if amplitude < 0.025 * top_feature:
                continue

            text = ezFCF_label_to_spectroscopic_label(assignment)

            ax.text(energy_eV, amplitude, text, **text_kwargs)


def set_limits(args, ax, xlims):

    ax.set_xlim([xlims[0], xlims[1]])

    if args.molecule is not None:
        if args.molecule == "pyrazine":
            # ax.set_ylim([0.0, 0.044])
            # Only the first band
            # ax.set_ylim([0.0, 0.005])
            ax.set_ylim([0.0, 0.0045])  # The best one
            # ax.set_ylim([0.0, 0.0040])
            # The offset example
            # ax.set_ylim([0.0, 0.027])

        elif args.molecule == "ozone":
            ax.set_xlim([12.4, 13.3])
            # ax.set_ylim([0.0, 0.535])  # the best one
            ax.set_ylim([0.0, 0.55])  # the zoomed-in one

        elif args.molecule == "ozone_zeke":
            ax.set_xlim([12.51, 12.91])
            # ax.set_ylim([0.0, 0.535])  # the best one
            # ax.set_ylim([-0.1, 1.5])  # the zoomed-in one
            ax.set_ylim([-0.1, 5.1])  # Add assignmnet

        elif args.molecule == "ozone_dyke":
            ax.set_xlim([12.25, 13.40])
            # ax.set_ylim([0.0, 0.535])  # the best one
            ax.set_ylim([0.0, 0.55])  # the zoomed-in one

        elif args.molecule == "ozone_no_cpl":
            ax.set_xlim([12.25, 13.3])
            # ax.set_ylim([0.0, 0.535])  # the best one
            ax.set_ylim([0.0, 0.95])  # the zoomed-in one

        elif args.molecule == "caoph":
            ax.set_xlim([1.95, 2.35])
            # ax.set_ylim([0.0, 0.535])


def get_config(args):
    config_file = os.path.expanduser(args.config)
    if os.path.isfile(config_file) is False:
        print(f"Info: No config file {args.config} present.", file=sys.stderr)
        return {}

    print(f"Info: Using the config file {args.config}.", file=sys.stderr)
    with open(config_file, 'rb') as config_toml:
        config = tomllib.load(config_toml)

    return config


def customize_yaxis(args, config, ax: mpl.axes.Axes):
    show_yaxis_ticks = None
    if 'show_yaxis_ticks' in config:
        show_yaxis_ticks = config['show_yaxis_ticks']
    if args.show_yaxis_ticks is not None:
        show_yaxis_ticks = args.show_yaxis_ticks

    if show_yaxis_ticks is None:
        show_yaxis_ticks = False  # set the default

    if show_yaxis_ticks is False:
        ax.get_yaxis().set_ticks([])

    if 'ylims' in config:
        ylims = config['ylims']
        ax.set_ylim(bottom=ylims['bottom'], top=ylims['top'])


def collect_spectra(args, config):
    # The format can be specified in the config file
    spectrum_format = None
    if 'spectrum_format' in config:
        if config['spectrum_format'] not in ['xsim', 'fort.20', 'ezFCF']:
            print("Error: the config file contains invalid spectrum format\n"
                  f"\tspectrum_format = {config['spectrum_format']}",
                  file=sys.stderr)
            sys.exit(1)
        spectrum_format = config['spectrum_format']
    # The command line can override it
    if args.spectrum_format is not None:
        spectrum_format = args.spectrum_format
    # if not specified it defaults to fort.20
    if spectrum_format is None:
        spectrum_format = "fort.20"

    if spectrum_format == "fort.20":
        basis = None
        spectra, lanczos = get_xsim_outputs_from_fort20(args)
    elif spectrum_format == "xsim":
        spectra, basis, lanczos = get_xsim_outputs(args)
    elif spectrum_format == "ezFCF":
        basis = None
        lanczos = None
        spectra = get_ezFCF_spectrum(args)
    else:
        print(f"Error: Unknown spectrum format {spectrum_format}",
              file=sys.stderr)

    return spectra, basis, lanczos, spectrum_format


def set_intensities(args, config, spectra):
    """
    Sometimes only the position of peaks is meaningful. Check if the switch
    'all_intensities_even' is set to any value is apply it.
    """
    even_intensites = None
    if 'all_intensities_even' in config:
        even_intensites = config['all_intensities_even']

    if args.all_intensities_even is not None:
        even_intensites = args.all_intensities_even

    if even_intensites is None:
        return spectra

    for spectrum in spectra:
        for peak in spectrum:
            peak['Relative intensity'] = even_intensites

    return spectra


def rescale_intensities(args, config, spectra):
    intensites_factor = None
    if 'rescale_intensities' in config:
        intensites_factor = config['rescale_intensities']

    if args.rescale_intensities is not None:
        intensites_factor = args.rescale_intensities

    if intensites_factor is None:
        return spectra

    for spectrum in spectra:
        for peak in spectrum:
            peak['Relative intensity'] *= intensites_factor

    return spectra


def main():
    args = parse_command_line()
    config = get_config(args)

    spectra, basis, lanczos, spectrum_format = collect_spectra(args, config)

    shift_eV = find_shift(spectra, args, config)
    *xlims, gamma = find_left_right_gamma(spectra, args, config)
    spectra = apply_shift(spectra, shift_eV)
    fig, ax = get_fig_and_ax(args, config)

    spectra = set_intensities(args, config, spectra)
    spectra = rescale_intensities(args, config, spectra)
    envelope_max_y = add_envelope(ax, args, config, spectra, xlims, gamma)
    max_peak = add_peaks(ax, args, config, spectra, xlims)
    add_info_text(ax, args, config, shift_eV, basis, lanczos, gamma)

    top_feature = max(envelope_max_y, max_peak)
    if spectrum_format == "ezFCF":
        add_ezFCF_assignments(ax, args, config, spectra, top_feature)
    add_assignments(ax, args, config, top_feature)
    add_reference_spectra(ax, args, config)
    # if args.molecule == "ozone_zeke":
    #     ci_ozone_cation_cm = 104024.87948
    #     ci_ozone_cation_eV = ci_ozone_cation_cm * CM2eV
    #     # text_kw = dict(va='bottom', ha='right', rotation=-20,
    #     #                rotation_mode='anchor')
    #     xs = ci_ozone_cation_eV + shift_eV
    #     ax.vlines(xs, 0.0, 2.0, color='gray', linestyles='solid',
    #               linewidths=1, alpha=0.2)

    set_limits(args, ax, xlims)

    origin = get_origin(spectra)
    add_minor_ticks(args, config, ax)
    add_second_axis(args, config, ax, origin)

    customize_yaxis(args, config, ax)

    fig.tight_layout()

    filename = prepare_filename(args, config)
    dont_save = False
    if 'dont_save' in config:
        dont_save = config['dont_save']
    if args.dont_save is True:
        dont_save = True

    if dont_save is True:
        plt.show()
    else:
        print(f"File saved as: {filename}")
        plt.savefig(filename)

    return 0


if __name__ == '__main__':
    main()
